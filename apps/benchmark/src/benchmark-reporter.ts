import { writeFileSync } from 'fs';

export interface BenchmarkResult {
  name: string;
  messagesPerSecond: number;
  averageLatency: number;
  totalMessages: number;
  totalTime: number;
  memoryUsage: number;
  cpuUsage: number;
  concurrentClients: number;
  messageSize: number;
  packageSize?: {
    bundleSize: number;
    gzippedSize: number;
    dependencies: number;
    totalSize: number;
  };
}

export interface BenchmarkSuite {
  results: BenchmarkResult[];
  timestamp: string;
  environment: {
    nodeVersion: string;
    platform: string;
    arch: string;
  };
}

export class BenchmarkReporter {
  private results: BenchmarkResult[] = [];
  private timestamp: string;
  private environment: BenchmarkSuite['environment'];

  constructor() {
    this.timestamp = new Date().toISOString();
    this.environment = {
      nodeVersion: process.version,
      platform: process.platform,
      arch: process.arch,
    };
  }

  addResult(result: BenchmarkResult): void {
    this.results.push(result);
  }

  generateMarkdownReport(outputPath: string): void {
    const markdown = this.generateMarkdown();
    writeFileSync(outputPath, markdown, 'utf8');
    console.log(`ðŸ“Š Benchmark report generated: ${outputPath}`);
  }

  private generateMarkdown(): string {

    return `# SigmaSockets Benchmark Report

## Overview
Generated on: ${new Date(this.timestamp).toLocaleString()}
Environment: ${this.environment.platform} ${this.environment.arch} (Node.js ${this.environment.nodeVersion})

## Performance Results

${this.generatePerformanceTable()}

## Performance Analysis

${this.generatePerformanceAnalysis()}

## Package Size Analysis

${this.generatePackageSizeAnalysis()}

## Architecture Comparison

${this.generateArchitectureDiagram()}

## Performance Trends

${this.generatePerformanceChart()}

## Detailed Results

${this.generateDetailedResults()}

## Recommendations

${this.generateRecommendations()}

---
*Report generated by SigmaSockets Benchmark Suite*
`;
  }

  private generatePerformanceTable(): string {
    if (this.results.length === 0) {
      return 'No benchmark results available.';
    }

    const table = [
      '| Implementation | Messages/sec | Avg Latency (ms) | Memory (MB) | CPU % | Clients | Message Size | Bundle Size |',
      '|----------------|--------------|------------------|-------------|-------|---------|--------------|-------------|'
    ];

    this.results.forEach(result => {
      const bundleSize = result.packageSize ? 
        `${(result.packageSize.bundleSize / 1024).toFixed(1)}KB` : 
        'N/A';
      table.push(
        `| ${result.name} | ${result.messagesPerSecond.toLocaleString()} | ${result.averageLatency.toFixed(2)} | ${(result.memoryUsage / 1024 / 1024).toFixed(1)} | ${result.cpuUsage.toFixed(1)} | ${result.concurrentClients} | ${result.messageSize} bytes | ${bundleSize} |`
      );
    });

    return table.join('\n');
  }

  private generatePerformanceAnalysis(): string {
    if (this.results.length === 0) return '';

    const fastest = this.results.reduce((prev, current) => 
      prev.messagesPerSecond > current.messagesPerSecond ? prev : current
    );
    const lowestLatency = this.results.reduce((prev, current) => 
      prev.averageLatency < current.averageLatency ? prev : current
    );
    const mostEfficient = this.results.reduce((prev, current) => 
      (prev.messagesPerSecond / prev.memoryUsage) > (current.messagesPerSecond / current.memoryUsage) ? prev : current
    );

    return `
### Key Findings

- **Fastest Throughput**: ${fastest.name} with ${fastest.messagesPerSecond.toLocaleString()} messages/second
- **Lowest Latency**: ${lowestLatency.name} with ${lowestLatency.averageLatency.toFixed(2)}ms average latency
- **Most Memory Efficient**: ${mostEfficient.name} with ${(mostEfficient.messagesPerSecond / mostEfficient.memoryUsage * 1024 * 1024).toFixed(0)} messages/MB

### Performance Characteristics

${this.results.map(result => `
**${result.name}**:
- High-throughput design optimized for ${result.messagesPerSecond > 100000 ? 'bulk messaging' : 'real-time communication'}
- ${result.averageLatency < 1 ? 'Ultra-low latency' : result.averageLatency < 10 ? 'Low latency' : 'Moderate latency'} performance
- Memory usage: ${(result.memoryUsage / 1024 / 1024).toFixed(1)}MB
- CPU efficiency: ${result.cpuUsage.toFixed(1)}% utilization
`).join('')}
`;
  }

  private generatePackageSizeAnalysis(): string {
    const resultsWithSize = this.results.filter(r => r.packageSize);
    if (resultsWithSize.length === 0) return 'Package size information not available.';

    const smallest = resultsWithSize.reduce((prev, current) => 
      prev.packageSize!.bundleSize < current.packageSize!.bundleSize ? prev : current
    );
    const largest = resultsWithSize.reduce((prev, current) => 
      prev.packageSize!.bundleSize > current.packageSize!.bundleSize ? prev : current
    );

    return `
### Bundle Size Comparison

| Implementation | Bundle Size | Gzipped | Dependencies | Total Size | Size/Msg/sec |
|----------------|-------------|---------|--------------|------------|--------------|
${resultsWithSize.map(result => {
  const sizePerMsg = result.packageSize!.bundleSize / result.messagesPerSecond;
  return `| ${result.name} | ${(result.packageSize!.bundleSize / 1024).toFixed(1)}KB | ${(result.packageSize!.gzippedSize / 1024).toFixed(1)}KB | ${(result.packageSize!.dependencies / 1024).toFixed(1)}KB | ${(result.packageSize!.totalSize / 1024).toFixed(1)}KB | ${sizePerMsg.toFixed(3)} bytes/msg/sec |`;
}).join('\n')}

### Size Efficiency Analysis

- **Smallest Bundle**: ${smallest.name} at ${(smallest.packageSize!.bundleSize / 1024).toFixed(1)}KB
- **Largest Bundle**: ${largest.name} at ${(largest.packageSize!.bundleSize / 1024).toFixed(1)}KB
- **Size Difference**: ${((largest.packageSize!.bundleSize - smallest.packageSize!.bundleSize) / 1024).toFixed(1)}KB (${((largest.packageSize!.bundleSize / smallest.packageSize!.bundleSize - 1) * 100).toFixed(1)}% larger)

### Performance vs Size Trade-offs

${resultsWithSize.map(result => {
  const sizePerMsg = result.packageSize!.bundleSize / result.messagesPerSecond;
  const efficiency = result.messagesPerSecond / (result.packageSize!.bundleSize / 1024);
  return `
**${result.name}**:
- Bundle efficiency: ${efficiency.toFixed(0)} messages/sec per KB
- Size per message: ${sizePerMsg.toFixed(3)} bytes
- ${result.packageSize!.bundleSize < 50000 ? 'Lightweight' : result.packageSize!.bundleSize < 100000 ? 'Moderate' : 'Heavy'} bundle size
- ${result.packageSize!.gzippedSize < result.packageSize!.bundleSize * 0.3 ? 'Excellent' : 'Good'} compression ratio`;
}).join('')}
`;
  }

  private generateArchitectureDiagram(): string {
    return `
\`\`\`mermaid
graph TB
    subgraph "Client Layer"
        C1[Client 1]
        C2[Client 2]
        C3[Client N]
    end
    
    subgraph "SigmaSockets Implementation"
        SS[SigmaSocketServer]
        FB[FlatBuffers Serialization]
        WS[WebSocket Transport]
    end
    
    subgraph "Alternative Implementations"
        UWS[ÂµWebSockets]
        WS_NATIVE[Node.js WebSocket]
    end
    
    subgraph "Performance Metrics"
        THROUGHPUT[Throughput: messages/sec]
        LATENCY[Latency: ms]
        MEMORY[Memory: MB]
        CPU[CPU: %]
    end
    
    C1 --> SS
    C2 --> SS
    C3 --> SS
    
    SS --> FB
    SS --> WS
    
    SS --> THROUGHPUT
    SS --> LATENCY
    SS --> MEMORY
    SS --> CPU
    
    UWS --> THROUGHPUT
    WS_NATIVE --> THROUGHPUT
    
    style SS fill:#e1f5fe
    style FB fill:#f3e5f5
    style WS fill:#e8f5e8
\`\`\`
`;
  }

  private generatePerformanceChart(): string {
    if (this.results.length === 0) return '';

    const maxThroughput = Math.max(...this.results.map(r => r.messagesPerSecond));
    const maxLatency = Math.max(...this.results.map(r => r.averageLatency));

    return `
\`\`\`mermaid
xychart-beta
    title "Performance Comparison"
    x-axis ["${this.results.map(r => r.name).join('", "')}"]
    y-axis "Messages per Second" 0 --> ${Math.ceil(maxThroughput / 10000) * 10000}
    bar [${this.results.map(r => r.messagesPerSecond).join(', ')}]
\`\`\`

\`\`\`mermaid
xychart-beta
    title "Latency Comparison"
    x-axis ["${this.results.map(r => r.name).join('", "')}"]
    y-axis "Average Latency (ms)" 0 --> ${Math.ceil(maxLatency)}
    bar [${this.results.map(r => r.averageLatency).join(', ')}]
\`\`\`
`;
  }

  private generateDetailedResults(): string {
    return this.results.map(result => `
### ${result.name}

- **Messages per Second**: ${result.messagesPerSecond.toLocaleString()}
- **Average Latency**: ${result.averageLatency.toFixed(2)}ms
- **Total Messages**: ${result.totalMessages.toLocaleString()}
- **Total Time**: ${result.totalTime.toFixed(2)}s
- **Memory Usage**: ${(result.memoryUsage / 1024 / 1024).toFixed(1)}MB
- **CPU Usage**: ${result.cpuUsage.toFixed(1)}%
- **Concurrent Clients**: ${result.concurrentClients}
- **Message Size**: ${result.messageSize} bytes

**Performance Score**: ${this.calculatePerformanceScore(result).toFixed(1)}/100
`).join('');
  }

  private generateRecommendations(): string {
    if (this.results.length === 0) return '';

    const recommendations = [];

    // Find best performers
    const bestThroughput = this.results.reduce((prev, current) => 
      prev.messagesPerSecond > current.messagesPerSecond ? prev : current
    );
    const bestLatency = this.results.reduce((prev, current) => 
      prev.averageLatency < current.averageLatency ? prev : current
    );

    recommendations.push(`- **For High-Throughput Applications**: Use ${bestThroughput.name} for maximum message processing capacity`);
    recommendations.push(`- **For Low-Latency Applications**: Use ${bestLatency.name} for minimal response times`);

    // Memory efficiency recommendations
    const memoryEfficient = this.results.reduce((prev, current) => 
      prev.memoryUsage < current.memoryUsage ? prev : current
    );
    recommendations.push(`- **For Memory-Constrained Environments**: Use ${memoryEfficient.name} for optimal memory usage`);

    // General recommendations
    recommendations.push('- **Production Deployment**: Consider load balancing across multiple instances for scalability');
    recommendations.push('- **Monitoring**: Implement comprehensive metrics collection for performance tracking');
    recommendations.push('- **Optimization**: Profile application-specific workloads for fine-tuning');

    return recommendations.join('\n');
  }

  private calculatePerformanceScore(result: BenchmarkResult): number {
    // Weighted scoring: 40% throughput, 30% latency, 20% memory efficiency, 10% CPU efficiency
    const maxThroughput = Math.max(...this.results.map(r => r.messagesPerSecond));
    const minLatency = Math.min(...this.results.map(r => r.averageLatency));
    const minMemory = Math.min(...this.results.map(r => r.memoryUsage));
    const minCPU = Math.min(...this.results.map(r => r.cpuUsage));

    const throughputScore = (result.messagesPerSecond / maxThroughput) * 40;
    const latencyScore = (minLatency / result.averageLatency) * 30;
    const memoryScore = (minMemory / result.memoryUsage) * 20;
    const cpuScore = (minCPU / result.cpuUsage) * 10;

    return throughputScore + latencyScore + memoryScore + cpuScore;
  }
}
